What is distributed systems:
A distributed system is a collection of independent computers that collaborate to achieve a common goal, 
functioning as a single unit to the end-user.
 
RAC DS FS SMD
R: Requirement
A: Architecture
C: Communication protocol 

D: Data management
S: Storage(type of DB)

F: Fault tolerance
S: Scalability

S: Security
M: Monitoring
D: Deployment

Designing a distributed system involves a series of strategic decisions to ensure scalability, fault tolerance, consistency, and maintainability. Here's a step-by-step approach to designing one:

1. Define Requirements
   Functional: What does the system need to do?
   Non-functional: Consider latency, availability, scalability, durability, and consistency.

2. Choose an Architecture
   Client-Server: Common, simple.
   Microservices: Small, independently deployable services.
   Peer-to-Peer: All nodes are equal.
   Event-driven: Services communicate via events.

3. Decide on Communication Protocol
   Synchronous: REST, gRPC.
   Asynchronous: Message queues (Kafka, RabbitMQ).

4. Data Management
   Data partitioning (sharding): Split data across nodes.
   Replication: Increase availability and durability.

   Consistency model:
      Strong consistency (CP in CAP)
      Eventual consistency (AP in CAP)

5. Choose Storage
   Relational: PostgreSQL, MySQL.
   NoSQL: MongoDB, Cassandra, DynamoDB.

6. Fault Tolerance and Reliability
   Redundancy (multiple nodes/services)
   Health checks and failover
   Retry logic and circuit breakers

7. Scalability
   Horizontal vs. vertical scaling
   Load balancing (e.g., NGINX, HAProxy)
   Auto-scaling strategies

8. Security
   Authentication and authorization (e.g., OAuth2)
   Encryption in transit and at rest
   Secure APIs and rate limiting

9. Monitoring and Observability
   Logging (e.g., ELK stack)
   Metrics (e.g., Prometheus, Grafana)
   Tracing (e.g., OpenTelemetry, Jaeger)

10. Deployment and Management
    Use containers (e.g., Docker)
    Orchestrate with Kubernetes
    CI/CD

------------------------------------------------------------------------------------------------------------------

1. Define Requirements
   Functional
   What the system does (features, workflows)
   
   Non-Functional
   Latency: response time
   Throughput: requests/sec
   Availability: uptime (99.9%)
   Consistency: same data for all users
   Reliability: failure frequency
   Maintainability: ease of changes
   Durability: data never lost
   Scalability choice: horizontal preferred
   Cost: infra + maintenance
---------------------------------------------------------------------------------------------------
2. Choose an Architecture
   Architectural Styles
   Monolith: simple, hard to scale
   Microservices: scalable, complex
   Event-Driven: async, loosely coupled
   Serverless: no infra mgmt, cold starts
   Stateful: stores session (hard scale)
   Stateless: no session (easy scale)
   Pub/Sub: event broadcasting

   Patterns
   Client-Server: common, simple
   Peer-to-Peer: decentralized, complex
----------------------------------------------------------------------------------------------------
3. Communication Protocols
   Synchronous
   HTTP/REST: simple, stateless
   gRPC: fast, binary
   WebSockets: real-time, persistent

   Asynchronous
   Message Queues: decoupling, resilience
   Pub/Sub: event distribution

   Infra
   API Gateway: auth, routing, rate limit
   Forward Proxy: client protection
   Reverse Proxy: server protection
---------------------------------------------------------------------------------------
4. Data Management
   Databases
   SQL: strong consistency
   NoSQL: scalability, flexibility
   Redis: caching, sessions

   Modeling
   Normalization: reduce redundancy
   Denormalization: faster reads
   Query optimization: indexes, joins

   Distribution
   Replication: availability
   Sharding: scalability
   CAP: choose 2 (C/A/P)
   Consistency: strong vs eventual

   Traffic Control
   Rate limiting: prevent abuse
   Algorithms: token bucket, leaky bucket
---------------------------------------------------------------------------------------
 5. Storage

   Block: low latency (DBs)
   Object: scalable (media)
   File: shared storage
   Backup & DR: RPO, RTO
---------------------------------------------------------------------------------------
6. Fault Tolerance & Reliability
   High availability: no single point of failure
   Fault tolerance: survive failures
   Reliability: fewer failures over time
   Consensus: leader election (Raft)

   Failure Handling
   Health checks
   Failover
   Retry + backoff
   Circuit breakers
---------------------------------------------------------------------------------------------
7. Scalability
   Scaling
   Horizontal: add nodes
   Vertical: bigger machine
   Bottlenecks: CPU, DB, network

   Load Distribution
   Load balancer
   Algorithms: round-robin, least-conn
   Consistent hashing

   Performance
   Caching: reduce DB load
   CDN: global low latency
   Concurrency â‰  Parallelism
------------------------------------------------------------------------------------------
8. Security
   AuthN: who you are
   AuthZ: what you can access
   SSL/TLS: encrypt in transit
   mTLS: service-to-service trust
   SSDLC: security in all phases
---------------------------------------------------------------------------------------------------
9. Monitoring & Observability
   Logs: debugging
   Metrics: latency, errors, QPS
   Tracing: request path
   Optimization: profiling, load tests
----------------------------------------------------------------------------------------------
10. Deployment & Management
  CI/CD: automated build & deploy
  Runtime
  Docker: consistent environment
  Kubernetes: scaling, self-healing
